## LIS(Longest Increasing Subsequence) 알고리즘

- 가장 긴(최장) 증가하는 부분 수열 알고리즘
  - 알고리즘 외로도 수학, 랜덤 행렬 이론, 표현론, 그리고 물리학과 관련된 다양한 분야에서 연구
- 주어진 수열에서 오름차순으로 정렬된 가장 긴 부분수열을 찾는 문제
  - 여기서 부분 수열은 **연속적이거나 유일할 필요는 없음**
- 최장 증가 부분 수열 문제는, 입력 수열의 길이가 *n*일 때 O(n^2) 또는 O(*n*log*n*)의 시간복잡도로 풀이 가능

## 문제 예시

```
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 S = {10, 20, 30, 50} 이고, 길이는 4이다.

또 다른 예시로, 수열 A = {277, 730, 790, 994, 242, 185, 633, 545, 830, 557, 194, 994, 44, 28, 755, 661} 인 경우에 가장 긴 증가하는 부분 수열은 S = {227, 730, 790, 830, 994} 이고, 길이는 5이다.
```

## 메모제이션을 통한 풀이 : O(n^2)

### 접근 방법

- 첫 번째 숫자 ~ 마지막 숫자까지 순회를 하는데,
    - 현재 숫자 기준 최장 증가 부분 수열(LIS) 길이는 1로 초기화
- 현재 숫자를 기준으로 이전 숫자들 보다 큰지 비교
- (크다면) 현재 숫자 기준 LIS 길이와 이전 숫자 기준 LIS 길이(메모라이징된 값)와 비교
- (이전 숫자 기준 LIS 길이가 현재 숫자 기준 LIS 길이 보다 크거나 같다면) 현재 숫자 기준 LIS를 **이전 숫자 기준 LIS + 1로 초기화**

### 예시

![image](https://user-images.githubusercontent.com/82401504/218252633-dde0330d-553b-41be-9c18-abb41c0ca323.png)
![image](https://user-images.githubusercontent.com/82401504/218252648-6aa0d641-35a0-4f34-9fc5-6f0c04cd287b.png)
![image](https://user-images.githubusercontent.com/82401504/218252654-018dc354-454d-4360-90ce-87600a8eaae5.png)
![image](https://user-images.githubusercontent.com/82401504/218252663-3a7a3fd8-771b-4895-bf3b-8326ea068343.png)

## 문제점

- 주어진 데이터가 1,000이 아니라 1,000,000이라면???
- O(n^2)의 알고리즘으로 처리하기에는 다소 무리!
- 이분 탐색을 활용하여 가장 긴 증가하는 부분 수열 길이 구해보자
